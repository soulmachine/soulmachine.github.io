<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | soulmachine]]></title>
  <link href="http://www.soulmachine.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.soulmachine.me/"/>
  <updated>2015-07-23T15:46:32-07:00</updated>
  <id>http://www.soulmachine.me/</id>
  <author>
    <name><![CDATA[soulmachine]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Calling C Code From Java Using JNI]]></title>
    <link href="http://www.soulmachine.me/blog/2015/07/23/calling-c-code-from-java-using-jni/"/>
    <updated>2015-07-23T02:28:28-07:00</updated>
    <id>http://www.soulmachine.me/blog/2015/07/23/calling-c-code-from-java-using-jni</id>
    <content type="html"><![CDATA[<p>This blog is a fork of <a href="http://stuf.ro/calling-c-code-from-java-using-jni">http://stuf.ro/calling-c-code-from-java-using-jni</a> with some errors fixed and C++ support added.</p>

<p>In this tutorial we&rsquo;ll be creating a Java application calling code from a native library. We&rsquo;ll have a Java application called <code>HelloWorld</code> which will call the function <code>helloFromC</code> from a shared library named <code>ctest</code>, using Java Native Interface.</p>

<p>First off, we&rsquo;ll create a file named <code>HelloWorld.java</code> to contain the <code>HelloWorld</code> class.</p>

<p>```java
/<em> HelloWorld.java </em>/</p>

<p>public class HelloWorld {</p>

<pre><code>native void helloFromC(); /* (1) */
static public void main(String argv[]) {
    System.loadLibrary("ctest"); /* (2) */
    HelloWorld helloWorld = new HelloWorld();
    helloWorld.helloFromC(); /* (3) */
}
</code></pre>

<p>}
```</p>

<ol>
<li>Make the JVM aware of a function defined externally, named <code>helloFromC</code></li>
<li>Load an external library called <code>ctest</code> (which will need to define this function)</li>
<li>Call the function we talked about</li>
</ol>


<p>Even though we didn&rsquo;t write any library yet, we can still compile the Java application, because this is a dependency that will be resolved at runtime. So, let&rsquo;s compile the application:</p>

<pre><code>javac HelloWorld.java
</code></pre>

<!-- more -->


<p>This will generate a HelloWorld.class file containing the application. Running the application will now result in an error, as we expect, because the library is not created yet:</p>

<pre><code>java -cp . HelloWorld

Exception in thread "main" java.lang.UnsatisfiedLinkError: no ctest in java.library.path
    at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1754)
    at java.lang.Runtime.loadLibrary0(Runtime.java:823)
    at java.lang.System.loadLibrary(System.java:1045)
    at HelloWorld.(HelloWorld.java:6)
</code></pre>

<p>Alright, let&rsquo;s now start writing the ctest library in C. To do that, we must first generate a header file from the .class file we created earlier. This header file will contain the definition of the function as it must be present in the C file.</p>

<pre><code>javah -cp . HelloWorld
</code></pre>

<p>This command will generate a <code>HelloWorld.h</code> file in the same directory, containing the following code:</p>

<p>```c
/<em> DO NOT EDIT THIS FILE &ndash; it is machine generated </em>/</p>

<h1>include &lt;jni.h></h1>

<p>/<em> Header for class HelloWorld </em>/</p>

<h1>ifndef _Included_HelloWorld</h1>

<h1>define _Included_HelloWorld</h1>

<h1>ifdef __cplusplus</h1>

<p>extern &ldquo;C&rdquo; {</p>

<h1>endif</h1>

<p>/<em>
 * Class:     HelloWorld
 * Method:    helloFromC
 * Signature: ()V
 </em>/
JNIEXPORT void JNICALL Java_HelloWorld_helloFromC
  (JNIEnv *, jobject);</p>

<h1>ifdef __cplusplus</h1>

<p>}</p>

<h1>endif</h1>

<h1>endif</h1>

<p>```</p>

<p>We&rsquo;ll leave this file exactly as is, as the comment suggests, but we need to copy the function definition. Copy the definition and put it in a new file, named ctest.c:</p>

<p>```c
/<em> ctest.c </em>/</p>

<p>JNIEXPORT void JNICALL Java_HelloWorld_helloFromC
  (JNIEnv * env, jobject jobj)
{
}
```</p>

<p>Note that we gave names to the parameters. Now let&rsquo;s implement the function. Aside from our own includes, we also need to include jni.h for this to work. So, modify the ctest.c file to contain something like:</p>

<p>```c
/<em> ctest.c </em>/</p>

<h1>include &lt;jni.h></h1>

<h1>include &lt;stdio.h></h1>

<p>JNIEXPORT void JNICALL Java_HelloWorld_helloFromC
  (JNIEnv * env, jobject jobj)
{</p>

<pre><code>printf("Hello from C!\n");
</code></pre>

<p>}
```</p>

<p>Now that we have the file, let&rsquo;s compile it and create a native library. This part is system dependent, but the only things that change really are the extension of the generated library file and the path to the jni.h include.</p>

<pre><code>gcc -shared -fpic -I$JAVA_HOME/include -I$JAVA_HOME/include/linux ctest.c -o libctest.so
</code></pre>

<p>Replace .so with .dylib if you&rsquo;re on a Mac, or .dll if you&rsquo;re on Windows (remove the lib part from the file name as well if you&rsquo;re on Windows). Also, replace /path/to/jdk/headers with the full path to the directory containing the file jni.h. If you don&rsquo;t know where that is, you can use the locate jni.h command on UNIX-like systems.</p>

<p>Once you successfully run the above command, you will see a libctest.so file in the current directory (or libctest.dylib or libctest.dll). If you remember from the Java code you wrote earlier, the virtual machine will expect a library named ctest to reside in the current directory (point 2). By that, it means that a file with the name libctest.so should be here, which you just created.</p>

<p>To see this in action, run the application:</p>

<pre><code>java -cp . -Djava.library.path=. HelloWorld
</code></pre>

<p>If everything works correctly, you should see:</p>

<pre><code>Hello from C!
</code></pre>

<p><strong>If we want to call C++ function, we need to make two changes. </strong></p>

<p>First,  rename the file <code>ctest.c</code> to <code>ctest.cpp</code> and append <code>extern "C"</code> to every function that we want to call from Java code.</p>

<p>```c++
/<em> ctest.cpp </em>/</p>

<h1>include &lt;jni.h></h1>

<h1>include &lt;stdio.h></h1>

<p>extern &ldquo;C&rdquo; JNIEXPORT void JNICALL Java_HelloWorld_helloFromC
  (JNIEnv * env, jobject jobj)
{</p>

<pre><code>printf("Hello from C++!\n");
</code></pre>

<p>}
```</p>

<p>Second, use <code>g++</code> instead of <code>gcc</code>, and link the Standard C++ library by adding the option <code>-lstdc++</code> to g++.</p>

<pre><code>g++ -shared -fpic -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -lstdc++ ctest.cpp -o libctest.so
</code></pre>

<p>To see if it works, run the application:</p>

<pre><code>java -cp . -Djava.library.path=. HelloWorld
</code></pre>

<p>If everything works correctly, you should see:</p>

<pre><code>Hello from C++!
</code></pre>

<h2>Reference</h2>

<ol>
<li><a href="http://stuf.ro/calling-c-code-from-java-using-jni">Calling C code from Java using JNI</a></li>
<li><a href="http://stackoverflow.com/questions/15090620/java-lang-unsatisfiedlinkerror-with-jni-and-c">java.lang.UnsatisfiedLinkError with JNI and c</a></li>
<li><a href="http://stackoverflow.com/questions/12353424/jni-change-c-to-c">JNI change C to C++</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compile and Run Java Source Code in Memory]]></title>
    <link href="http://www.soulmachine.me/blog/2015/07/22/compile-and-run-java-source-code-in-memory/"/>
    <updated>2015-07-22T15:42:18-07:00</updated>
    <id>http://www.soulmachine.me/blog/2015/07/22/compile-and-run-java-source-code-in-memory</id>
    <content type="html"><![CDATA[<p>In this blog I will show you how to compile and run Java source code on the fly in memory. In other words, use Java as a script language.</p>

<p>Here are the three source code files.</p>

<p>```java
package me.soulmachine.compiler;</p>

<p>import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;</p>

<p>import javax.tools.*;</p>

<p>/<em>*
 * Simple interface to Java compiler using JSR 199 Compiler API.
 </em>/
public class MemoryJavaCompiler {</p>

<pre><code>private javax.tools.JavaCompiler tool;
private StandardJavaFileManager stdManager;

public MemoryJavaCompiler() {
    tool = ToolProvider.getSystemJavaCompiler();
    if (tool == null) {
        throw new RuntimeException("Could not get Java compiler. Please, ensure that JDK is used instead of JRE.");
    }
    stdManager = tool.getStandardFileManager(null, null, null);
}

/**
 * Compile a single static method.
 */
public Method compileStaticMethod(final String methodName, final String className,
    final String source)
    throws ClassNotFoundException {
    final Map&lt;String, byte[]&gt; classBytes = compile(className + ".java", source);
    final MemoryClassLoader classLoader = new MemoryClassLoader(classBytes);
    final Class clazz = classLoader.loadClass(className);
    final Method[] methods = clazz.getDeclaredMethods();
    for (final Method method : methods) {
        if (method.getName().equals(methodName)) {
            if (!method.isAccessible()) method.setAccessible(true);
            return method;
        }
    }
    throw new NoSuchMethodError(methodName);
}


public Map&lt;String, byte[]&gt; compile(String fileName, String source) {
    return compile(fileName, source, new PrintWriter(System.err), null, null);
}


/**
 * compile given String source and return bytecodes as a Map.
 *
 * @param fileName source fileName to be used for error messages etc.
 * @param source Java source as String
 * @param err error writer where diagnostic messages are written
 * @param sourcePath location of additional .java source files
 * @param classPath location of additional .class files
 */
private Map&lt;String, byte[]&gt; compile(String fileName, String source,
    Writer err, String sourcePath, String classPath) {
    // to collect errors, warnings etc.
    DiagnosticCollector&lt;JavaFileObject&gt; diagnostics =
        new DiagnosticCollector&lt;JavaFileObject&gt;();

    // create a new memory JavaFileManager
    MemoryJavaFileManager fileManager = new MemoryJavaFileManager(stdManager);

    // prepare the compilation unit
    List&lt;JavaFileObject&gt; compUnits = new ArrayList&lt;JavaFileObject&gt;(1);
    compUnits.add(fileManager.makeStringSource(fileName, source));

    return compile(compUnits, fileManager, err, sourcePath, classPath);
}

private Map&lt;String, byte[]&gt; compile(final List&lt;JavaFileObject&gt; compUnits, 
    final MemoryJavaFileManager fileManager,
    Writer err, String sourcePath, String classPath) {
    // to collect errors, warnings etc.
    DiagnosticCollector&lt;JavaFileObject&gt; diagnostics =
        new DiagnosticCollector&lt;JavaFileObject&gt;();

    // javac options
    List&lt;String&gt; options = new ArrayList&lt;String&gt;();
    options.add("-Xlint:all");
    //      options.add("-g:none");
    options.add("-deprecation");
    if (sourcePath != null) {
        options.add("-sourcepath");
        options.add(sourcePath);
    }

    if (classPath != null) {
        options.add("-classpath");
        options.add(classPath);
    }

    // create a compilation task
    javax.tools.JavaCompiler.CompilationTask task =
        tool.getTask(err, fileManager, diagnostics,
            options, null, compUnits);

    if (task.call() == false) {
        PrintWriter perr = new PrintWriter(err);
        for (Diagnostic diagnostic : diagnostics.getDiagnostics()) {
            perr.println(diagnostic);
        }
        perr.flush();
        return null;
    }

    Map&lt;String, byte[]&gt; classBytes = fileManager.getClassBytes();
    try {
        fileManager.close();
    } catch (IOException exp) {
    }

    return classBytes;
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p>```java
package me.soulmachine.compiler;</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.nio.CharBuffer;
import java.util.HashMap;
import java.util.Map;</p>

<p>import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.JavaFileObject.Kind;
import javax.tools.SimpleJavaFileObject;</p>

<p>/<em>*
 * JavaFileManager that keeps compiled .class bytes in memory.
 </em>/
@SuppressWarnings(&ldquo;unchecked&rdquo;)
final class MemoryJavaFileManager extends ForwardingJavaFileManager {</p>

<pre><code>/** Java source file extension. */
private final static String EXT = ".java";

private Map&lt;String, byte[]&gt; classBytes;

public MemoryJavaFileManager(JavaFileManager fileManager) {
    super(fileManager);
    classBytes = new HashMap&lt;&gt;();
}

public Map&lt;String, byte[]&gt; getClassBytes() {
    return classBytes;
}

public void close() throws IOException {
    classBytes = null;
}

public void flush() throws IOException {
}

/**
 * A file object used to represent Java source coming from a string.
 */
private static class StringInputBuffer extends SimpleJavaFileObject {
    final String code;

    StringInputBuffer(String fileName, String code) {
        super(toURI(fileName), Kind.SOURCE);
        this.code = code;
    }

    public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
        return CharBuffer.wrap(code);
    }
}

/**
 * A file object that stores Java bytecode into the classBytes map.
 */
private class ClassOutputBuffer extends SimpleJavaFileObject {
    private String name;

    ClassOutputBuffer(String name) {
        super(toURI(name), Kind.CLASS);
        this.name = name;
    }

    public OutputStream openOutputStream() {
        return new FilterOutputStream(new ByteArrayOutputStream()) {
            public void close() throws IOException {
                out.close();
                ByteArrayOutputStream bos = (ByteArrayOutputStream)out;
                classBytes.put(name, bos.toByteArray());
            }
        };
    }
}

public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location,
    String className,
    Kind kind,
    FileObject sibling) throws IOException {
    if (kind == Kind.CLASS) {
        return new ClassOutputBuffer(className);
    } else {
        return super.getJavaFileForOutput(location, className, kind, sibling);
    }
}

static JavaFileObject makeStringSource(String fileName, String code) {
    return new StringInputBuffer(fileName, code);
}

static URI toURI(String name) {
    File file = new File(name);
    if (file.exists()) {
        return file.toURI();
    } else {
        try {
            final StringBuilder newUri = new StringBuilder();
            newUri.append("mfm:///");
            newUri.append(name.replace('.', '/'));
            if(name.endsWith(EXT)) newUri.replace(newUri.length() - EXT.length(), newUri.length(), EXT);
            return URI.create(newUri.toString());
        } catch (Exception exp) {
            return URI.create("mfm:///com/sun/script/java/java_source");
        }
    }
}
</code></pre>

<p>}
```</p>

<p>```java
package me.soulmachine.compiler;</p>

<p>import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;</p>

<p>/<em>*
 * ClassLoader that loads .class bytes from memory.
 </em>/
final class MemoryClassLoader extends URLClassLoader {</p>

<pre><code>private Map&lt;String, byte[]&gt; classBytes;

public MemoryClassLoader(Map&lt;String, byte[]&gt; classBytes,
    String classPath, ClassLoader parent) {
    super(toURLs(classPath), parent);
    this.classBytes = classBytes;
}

public MemoryClassLoader(Map&lt;String, byte[]&gt; classBytes, String classPath) {
    this(classBytes, classPath, ClassLoader.getSystemClassLoader());
}

public MemoryClassLoader(Map&lt;String, byte[]&gt; classBytes) {
    this(classBytes, null, ClassLoader.getSystemClassLoader());
}

public Class load(String className) throws ClassNotFoundException {
    return loadClass(className);
}

public Iterable&lt;Class&gt; loadAll() throws ClassNotFoundException {
    List&lt;Class&gt; classes = new ArrayList&lt;Class&gt;(classBytes.size());
    for (String name : classBytes.keySet()) {
        classes.add(loadClass(name));
    }
    return classes;
}

protected Class findClass(String className) throws ClassNotFoundException {
    byte[] buf = classBytes.get(className);
    if (buf != null) {
        // clear the bytes in map -- we don't need it anymore
        classBytes.put(className, null);
        return defineClass(className, buf, 0, buf.length);
    } else {
        return super.findClass(className);
    }
}

private static URL[] toURLs(String classPath) {
    if (classPath == null) {
        return new URL[0];
    }

    List&lt;URL&gt; list = new ArrayList&lt;URL&gt;();
    StringTokenizer st = new StringTokenizer(classPath, File.pathSeparator);
    while (st.hasMoreTokens()) {
        String token = st.nextToken();
        File file = new File(token);
        if (file.exists()) {
            try {
                list.add(file.toURI().toURL());
            } catch (MalformedURLException mue) {}
        } else {
            try {
                list.add(new URL(token));
            } catch (MalformedURLException mue) {}
        }
    }
    URL[] res = new URL[list.size()];
    list.toArray(res);
    return res;
}
</code></pre>

<p>}
```</p>

<p><strong>Explanations</strong>:</p>

<ol>
<li>In order to represent a  Java source file in memory instead of disk, I defined a <code>StringInputBuffer</code> class in the <code>MemoryJavaFileManager.java</code>.</li>
<li>To save the compiled <code>.class</code> files in memory, I implemented a class <code>MemoryJavaFileManager</code>.  The main idea is to override the function <code>getJavaFileForOutput()</code> to store bytecodes into a map.</li>
<li>To load the bytecodes in memory, I have to implement a customized classloader <code>MemoryClassLoader</code>, which reads bytecodes in the map and turn them into classes.</li>
</ol>


<p>Here is a unite test.</p>

<p>```java
package me.soulmachine.compiler;</p>

<p>import org.junit.Test;</p>

<p>import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;</p>

<p>import static org.junit.Assert.assertEquals;</p>

<p>public class MemoryJavaCompilerTest {</p>

<pre><code>private final static MemoryJavaCompiler compiler = new MemoryJavaCompiler();

@Test public void compileStaticMethodTest()
    throws ClassNotFoundException, InvocationTargetException, IllegalAccessException {
    final String source = "public final class Solution {\n"
        + "public static String greeting(String name) {\n"
        + "\treturn \"Hello \" + name;\n" + "}\n}\n";
    final Method greeting = compiler.compileStaticMethod("greeting", "Solution", source);
    final Object result = greeting.invoke(null, "soulmachine");
    assertEquals("Hello soulmachine", result.toString());
}
</code></pre>

<p>}
```</p>

<h2>Reference</h2>

<ol>
<li><a href="https://github.com/kite-sdk/kite/tree/master/kite-morphlines/kite-morphlines-core/src/main/java/org/kitesdk/morphline/scriptengine/java">JavaCompiler.java from Cloudera Morphlines</a></li>
<li><a href="http://stackoverflow.com/questions/1168931/how-to-create-an-object-from-a-string-in-java-how-to-eval-a-string">How to create an object from a string in Java (how to eval a string)?</a></li>
<li><a href="https://github.com/trung/InMemoryJavaCompiler">InMemoryJavaCompiler</a></li>
<li><a href="https://github.com/OpenHFT/Java-Runtime-Compiler">Java-Runtime-Compiler</a></li>
<li><a href="http://pfmiles.github.io/blog/dynamic-java/">动态的Java &ndash; 无废话JavaCompilerAPI中文指南</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deserialize a JSON String to a Binary Tree]]></title>
    <link href="http://www.soulmachine.me/blog/2015/06/22/deserialize-a-json-string-to-a-binary-tree/"/>
    <updated>2015-06-22T01:36:02-07:00</updated>
    <id>http://www.soulmachine.me/blog/2015/06/22/deserialize-a-json-string-to-a-binary-tree</id>
    <content type="html"><![CDATA[<h2>A simple solution</h2>

<p>We know that Jackson is very convenient to deserialize a JSON string into a <code>ArrayList</code>, <code>HashMap</code> or POJO object.</p>

<p>But how to deserialize a JSON String to a binary tree?</p>

<p>The definition of binary tree node is as follows:</p>

<p>```java
public class BinaryTreeNode<E>
{</p>

<pre><code>public E value;
public BinaryTreeNode&lt;E&gt; left;
public BinaryTreeNode&lt;E&gt; right;
</code></pre>

<p>```</p>

<p>The JSON String is as follows:</p>

<pre><code>{
   "value": 2,
   "left": {
    "value": 1,
    "left": null,
    "right": null
  },
  "right": {
    "value": 10,
    "left": {
      "value": 5,
      "left": null,
      "right": null
    },
    "right": null
  }
}
</code></pre>

<p>The above JSON string represents a binary tree as the following:</p>

<pre><code>  2
 / \
1   10
   /
  5
</code></pre>

<p>The solution is quite simpler, since JSON can express tree naturally, Jackson can deal with recursive tree directly. Just annotate a constructor with <code>JsonCreator</code>:</p>

<p>```java
public static class BinaryTreeNode<E>
{</p>

<pre><code>public E value;
public BinaryTreeNode left;
public BinaryTreeNode right;

@JsonCreator
public BinaryTreeNode(@JsonProperty("value") final E value) {
    this.value = value;
}
</code></pre>

<p>}
```</p>

<p>Let&rsquo;s write a unite test to try it:</p>

<!-- more -->


<p>```java
package me.soulmachine.customized_collection;</p>

<p>import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;</p>

<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;</p>

<p>import static org.junit.Assert.assertEquals;</p>

<p>public class BinaryTreeNodeTest {</p>

<pre><code>public static class BinaryTreeNode&lt;E&gt; {
    public E value;
    public BinaryTreeNode left;
    public BinaryTreeNode right;

    @JsonCreator
    public BinaryTreeNode(@JsonProperty("value") final E value) {
        this.value = value;
    }

    ArrayList&lt;E&gt; preOrder() {
        final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();
        if (this.value == null) {
            return result;
        }
        preOrder(this, result);
        return result;
    }

    private static &lt;E&gt; void preOrder(BinaryTreeNode&lt;E&gt; root, ArrayList&lt;E&gt; result) {
        if (root == null)
            return;

        result.add(root.value);
        if (root.left != null)
            preOrder(root.left, result);
        if (root.right != null)
            preOrder(root.right, result);
    }
}
@Test public void binaryTreeNodeTest() throws IOException {
    ObjectMapper objectMapper = new ObjectMapper();
    /*
         2
        / \
       1   10
          /
         5
    */
    final String jsonStr = "{\n"
        + "  \"value\": 2,\n"
        + "  \"left\": {\n"
        + "    \"value\": 1,\n"
        + "    \"left\": null,\n"
        + "    \"right\": null\n"
        + "  },\n" + "  \"right\": {\n"
        + "    \"value\": 10,\n"
        + "    \"left\": {\n"
        + "      \"value\": 5,\n"
        + "      \"left\": null,\n"
        + "      \"right\": null\n"
        + "    },\n"
        + "    \"right\": null\n"
        + "  }\n"
        + "}";
    System.out.println(jsonStr);
    final BinaryTreeNode&lt;Integer&gt; intTree = objectMapper.readValue(jsonStr,
        new TypeReference&lt;BinaryTreeNode&lt;Integer&gt;&gt;() {});
    final List&lt;Integer&gt; listExpected = Arrays.asList(2, 1, 10, 5);
    assertEquals(listExpected, intTree.preOrder());
}
</code></pre>

<p>}
```</p>

<h2>A compact serialization format</h2>

<p>Well, there is a little problem here, the JSON string above is very verbose. Let&rsquo;s use another kind of serialization format, i.e., serialize a binary tree in level order traversal. For example, the binary tree above can be serialized as the following JSON string:</p>

<pre><code>[2,1,10,null,null,5] 
</code></pre>

<p>Now how to deserialize this JSON string to a binary tree?</p>

<p>The idea is very similar to my previous article, <a href="http://www.soulmachine.me/blog/2015/06/21/deserialize-a-json-array-to-a-singly-linked-list/">Deserialize a JSON Array to a Singly Linked List</a>. Just make the <code>BinaryTreeNode</code> implement <code>java.util.list</code>,  pretend that it&rsquo;s a list, write our own deserialization code so that Jackson can treat a binary tree as a list.</p>

<p>The complete code of <code>BinaryTreeNode</code> is as the following:</p>

<p>```java
package me.soulmachine.customized_collection;</p>

<p>import java.util.*;</p>

<p>public class BinaryTreeNode<E> extends AbstractSequentialList<E></p>

<pre><code>implements Cloneable, java.io.Serializable {
public E value;
public BinaryTreeNode&lt;E&gt; left;
public BinaryTreeNode&lt;E&gt; right;

/** has a left child, but it's a null node. */
private transient boolean leftIsNull;
/** has a right child, but it's a null node. */
private transient boolean rightIsNull;

/**
 * Constructs an empty binary tree.
 */
public BinaryTreeNode() {
    value = null;
    left = null;
    right = null;
}

/**
 * Constructs an binary tree with one element.
 */
public BinaryTreeNode(final E value) {
    if (value == null) throw new IllegalArgumentException("null value");
    this.value = value;
    left = null;
    right = null;
}

/**
 * Constructs a binary tree containing the elements of the specified
 * collection, in the order they are returned by the collection's
 * iterator.
 *
 * @param  c the collection whose elements are to be placed into this binary tree
 * @throws NullPointerException if the specified collection is null
 */
public BinaryTreeNode(Collection&lt;? extends E&gt; c) {
    this();
    addAll(c);
}

/**
 * @inheritDoc
 *
 * &lt;p&gt;Note: null in the middle counts, so that each father in the binary tree has a
 * one-to-one mapping with the JSON array.&lt;/p&gt;
 */
public int size() {
    if (value == null) return 0;

    Queue&lt;BinaryTreeNode&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.add(this);

    int count = 0;
    while (!queue.isEmpty()) {
        final BinaryTreeNode&lt;E&gt; node = queue.remove();
        ++count;
        if (node.left != null) {
            queue.add(node.left);
        } else {
            if (node.leftIsNull) ++count;
        }
        if (node.right != null) {
            queue.add(node.right);
        } else {
            if (node.rightIsNull) ++count;
        }
    }
    return count;
}

/**
 * Tells if the argument is the index of a valid position for an
 * iterator or an add operation.
 */
private boolean isPositionIndex(int index) {
    return index &gt;= 0 &amp;&amp; index &lt;= size();
}

/**
 * Constructs an IndexOutOfBoundsException detail message.
 * Of the many possible refactorings of the error handling code,
 * this "outlining" performs best with both server and client VMs.
 */
private String outOfBoundsMsg(int index) {
    return "Index: "+index+", Size: "+ size();
}

private void checkPositionIndex(int index) {
    if (!isPositionIndex(index))
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private class NodeAndFather {
    private BinaryTreeNode&lt;E&gt; node;
    private BinaryTreeNode&lt;E&gt; father;
    private boolean isRight;  // the father is the right child of the father

    private NodeAndFather(BinaryTreeNode&lt;E&gt; node, BinaryTreeNode&lt;E&gt; father, boolean isRight) {
        this.node = node;
        this.father = father;
        this.isRight = isRight;
    }
}

/**
 * Returns the (may be null) Node at the specified element index.
 */
NodeAndFather node(int index) {
    checkPositionIndex(index);
    if (value == null) return null;

    Queue&lt;NodeAndFather&gt; queue = new LinkedList&lt;&gt;();
    queue.add(new NodeAndFather(this, null, false));

    for (int i = 0; !queue.isEmpty(); ++i) {
        final NodeAndFather nodeAndFather = queue.remove();
        if ( i == index) {
            return nodeAndFather;
        }

        if (nodeAndFather.node != null) {
            queue.add(new NodeAndFather(nodeAndFather.node.left, nodeAndFather.node, false));
            queue.add(new NodeAndFather(nodeAndFather.node.right, nodeAndFather.node, true));
        }
    }
    throw new IllegalArgumentException("Illegal index: " + index);
}

/**
 * @inheritDoc
 */
public ListIterator&lt;E&gt; listIterator(int index) {
    checkPositionIndex(index);
    return new ListItr(index);
}

private class ListItr implements ListIterator&lt;E&gt; {
    private NodeAndFather next;
    private int nextIndex;
    private int expectedModCount = modCount;

    ListItr(int index) {
        assert isPositionIndex(index);
        next = node(index);
        nextIndex = index;
    }

    public boolean hasNext() {
        final BinaryTreeNode&lt;E&gt; cur = next.node;
        return cur != null || (next.father.leftIsNull || next.father.rightIsNull);
    }

    //O(n)
    public E next() {
        checkForComodification();
        if (!hasNext())
            throw new NoSuchElementException();

        final E result = next.node != null ? next.node.value : null;
        next = node(nextIndex+1);
        nextIndex++;
        return result;
    }

    public boolean hasPrevious() {
        throw new UnsupportedOperationException();
    }

    public E previous() {
        throw new UnsupportedOperationException();
    }

    public int nextIndex() {
        throw new UnsupportedOperationException();
    }

    public int previousIndex() {
        throw new UnsupportedOperationException();
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {  // always append at the tail
        checkForComodification();

        if (next == null) { // empty list
            BinaryTreeNode.this.value = e;
            BinaryTreeNode.this.left = null;
            BinaryTreeNode.this.right = null;
        } else {
            final BinaryTreeNode&lt;E&gt; newNode = e != null ? new BinaryTreeNode&lt;&gt;(e) : null;
            if (next.father == null) { // root
                BinaryTreeNode&lt;E&gt; cur = next.node;
                cur.left = newNode;
                assert cur.right == null;
                throw new UnsupportedOperationException();
            } else {
                if (next.isRight) {
                    if (next.father.right != null) throw new IllegalStateException();
                    next.father.right = newNode;
                    if (newNode == null) {
                        next.father.rightIsNull = true;
                    }
                } else {
                    if (next.father.left != null) throw new IllegalStateException();
                    next.father.left = newNode;
                    if (newNode == null) {
                        next.father.leftIsNull = true;
                    }

                }
            }
        }
        modCount++;
        expectedModCount++;
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}

// the following functions are just for unit tests.
ArrayList&lt;E&gt; preOrder() {
    final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();
    if (this.value == null) {
        return result;
    }
    preOrder(this, result);
    return result;
}

private static &lt;E&gt; void preOrder(BinaryTreeNode&lt;E&gt; root, ArrayList&lt;E&gt; result) {
    if (root == null)
        return;

    result.add(root.value);
    if (root.left != null)
        preOrder(root.left, result);
    if (root.right != null)
        preOrder(root.right, result);
}

ArrayList&lt;E&gt; inOrder() {
    final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();
    if (this.value == null) {
        return result;
    }
    inOrder(this, result);
    return result;
}

private static &lt;E&gt; void inOrder(BinaryTreeNode&lt;E&gt; root, ArrayList&lt;E&gt; result) {
    if (root == null)
        return;

    if (root.left != null)
        inOrder(root.left, result);
    result.add(root.value);
    if (root.right != null)
        inOrder(root.right, result);
}

ArrayList&lt;E&gt; postOrder() {
    final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();
    if (this.value == null) {
        return result;
    }
    postOrder(this, result);
    return result;
}

private static &lt;E&gt; void postOrder(BinaryTreeNode&lt;E&gt; root, ArrayList&lt;E&gt; result) {
    if (root == null)
        return;

    if (root.left != null)
        postOrder(root.left, result);
    if (root.right != null)
        postOrder(root.right, result);
    result.add(root.value);
}

ArrayList&lt;E&gt; levelOrder() {
    final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();
    if (this.value == null) {
        return result;
    }

    Queue&lt;BinaryTreeNode&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.add(this);

    while (!queue.isEmpty()) {
        final BinaryTreeNode&lt;E&gt; node = queue.remove();
        result.add(node.value);

        if (node.left != null)
            queue.add(node.left);

        if (node.right != null)
            queue.add(node.right);
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>Then comes with the unit tests:</p>

<p>```java
package me.soulmachine.customized_collection;</p>

<p>import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;</p>

<p>import java.io.IOException;
import java.util.Arrays;
import java.util.List;</p>

<p>import static org.junit.Assert.assertEquals;</p>

<p>public class BinaryTreeNodeTest
{</p>

<pre><code>@Test public void deserializeTest() throws IOException {
    ObjectMapper objectMapper = new ObjectMapper();
    final List&lt;Integer&gt; intList = Arrays.asList(2,1,10,null,null,5);

    /*
         2
        / \
       1   10
          /
         5
    */
    // TODO: the time complexity is O(n^2)
    final BinaryTreeNode&lt;Integer&gt; intTree = objectMapper.readValue("[2,1,10,null,null,5]",
        new TypeReference&lt;BinaryTreeNode&lt;Integer&gt;&gt;() {});
    assertEquals(intList, intTree);

    assertEquals(Arrays.asList(2, 1, 10, 5), intTree.levelOrder());
    assertEquals(Arrays.asList(2, 1, 10, 5), intTree.preOrder());
    assertEquals(Arrays.asList(1, 2, 5, 10), intTree.inOrder());
    assertEquals(Arrays.asList(1, 5, 10, 2), intTree.postOrder());
}
</code></pre>

<p>}
```</p>

<p>This article is inspired by <a href="https://github.com/cowtowncoder">Tatu Saloranta</a> from <a href="https://groups.google.com/forum/#!topic/jackson-user/LzfbT0fyLWc">this post</a>, special thanks to him!</p>

<h2>Related Posts</h2>

<p><a href="http://www.soulmachine.me/blog/2015/06/21/deserialize-a-json-array-to-a-singly-linked-list/">Deserialize a JSON Array to a Singly Linked List</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deserialize a JSON Array to a Singly Linked List]]></title>
    <link href="http://www.soulmachine.me/blog/2015/06/21/deserialize-a-json-array-to-a-singly-linked-list/"/>
    <updated>2015-06-21T21:19:53-07:00</updated>
    <id>http://www.soulmachine.me/blog/2015/06/21/deserialize-a-json-array-to-a-singly-linked-list</id>
    <content type="html"><![CDATA[<p>We know that Jackson is very convenient to deserialize a JSON string into a <code>ArrayList</code>, <code>HashMap</code> or POJO object.</p>

<p>But how to deserialize a JSON array, such as <code>[1,2,3,4,5]</code> to a singly linked list?</p>

<p>The definition of singly linked list is as follows:</p>

<p>```java
public class SinglyLinkedListNode<E>
{</p>

<pre><code>public E value;
public SinglyLinkedListNode&lt;E&gt; next;
</code></pre>

<p>}
```</p>

<p>Well, the solution is quite simpler than I expected:  Just make <code>SinglyLinkedListNode</code> implement <code>java.util.List</code> or <code>java.util.Collection</code> , Jackson will automatically deserialize it!</p>

<p>This idea comes from <a href="https://github.com/cowtowncoder">Tatu Saloranta</a>, the discussion post is <a href="https://groups.google.com/forum/#!topic/jackson-user/EbltfyXSVV8">here</a>, special thanks to him!</p>

<p>Here is the complete code of <code>SinglyLinkedListNode</code>:</p>

<!-- more -->


<p>```java
package org.algorithmhub.customized_collection;</p>

<p>import java.util.*;</p>

<p>/<em>*
 * Singly Linked List.
 *
 * <p>As to singly linked list, a node can be viewed as a single node,
 * and it can be viewed as a list too.</p>
 *
 * @param <E> the type of elements held in this collection
 * @see java.util.LinkedList
 </em>/
public class SinglyLinkedListNode<E></p>

<pre><code>extends AbstractSequentialList&lt;E&gt;
implements Cloneable, java.io.Serializable
</code></pre>

<p>{</p>

<pre><code>public E value;
public SinglyLinkedListNode&lt;E&gt; next;

/**
 * Constructs an empty list.
 */
public SinglyLinkedListNode() {
    value = null;
    next = null;
}

/**
 * Constructs an list with one element.
 */
public SinglyLinkedListNode(final E value, SinglyLinkedListNode&lt;E&gt; next) {
    this.value = value;
    this.next = next;
}

/**
 * Constructs a list containing the elements of the specified
 * collection, in the order they are returned by the collection's
 * iterator.
 *
 * @param  c the collection whose elements are to be placed into this list
 * @throws NullPointerException if the specified collection is null
 */
public SinglyLinkedListNode(Collection&lt;? extends E&gt; c) {
    this();
    addAll(c);
}

/**
 * @inheritDoc
 */
public int size() {
    int size = 0;
    if (value == null) return size;

    SinglyLinkedListNode&lt;E&gt; cur = this;
    while (cur != null) {
        size++;
        cur = cur.next;
    }
    return size;
}

/**
 * Tells if the argument is the index of a valid position for an
 * iterator or an add operation.
 */
private boolean isPositionIndex(int index) {
    return index &gt;= 0 &amp;&amp; index &lt;= size();
}

/**
 * Constructs an IndexOutOfBoundsException detail message.
 * Of the many possible refactorings of the error handling code,
 * this "outlining" performs best with both server and client VMs.
 */
private String outOfBoundsMsg(int index) {
    return "Index: "+index+", Size: " + size();
}

private void checkPositionIndex(int index) {
    if (!isPositionIndex(index))
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private class PositionInfo {
    private SinglyLinkedListNode&lt;E&gt; prev;
    private SinglyLinkedListNode&lt;E&gt; cur;
    private PositionInfo(SinglyLinkedListNode&lt;E&gt; prev, SinglyLinkedListNode&lt;E&gt; cur) {
        this.prev = prev;
        this.cur = cur;
    }
}
/**
 * Returns the (non-null) Node at the specified element index.
 */
PositionInfo node(int index) {
    checkPositionIndex(index);
    if (this.value == null) return new PositionInfo(null, null);

    SinglyLinkedListNode&lt;E&gt; prev = new SinglyLinkedListNode&lt;E&gt;(null, this);
    SinglyLinkedListNode&lt;E&gt; cur = this;
    for (int i = 0; i &lt; index; i++) {
        prev = prev.next;
        cur = cur.next;
    }
    return new PositionInfo(prev, cur);
}

/**
 * @inheritDoc
 */
public ListIterator&lt;E&gt; listIterator(int index) {
    checkPositionIndex(index);
    return new ListItr(index);
}

private class ListItr implements ListIterator&lt;E&gt; {
    private SinglyLinkedListNode&lt;E&gt; prev;
    private SinglyLinkedListNode&lt;E&gt; cur;
    private int expectedModCount = modCount;

    ListItr(int index) {
        assert isPositionIndex(index);
        final PositionInfo positionInfo = node(index);
        prev = positionInfo.prev;
        cur = positionInfo.cur;
    }

    public boolean hasNext() {
        return cur != null;
    }

    public E next() {
        checkForComodification();
        if (!hasNext())
            throw new NoSuchElementException();

        final E result = cur.value;
        cur = cur.next;
        return result;
    }

    public boolean hasPrevious() {
        throw new UnsupportedOperationException();
    }

    public E previous() {
        throw new UnsupportedOperationException();
    }

    public int nextIndex() {
        throw new UnsupportedOperationException();
    }

    public int previousIndex() {
        throw new UnsupportedOperationException();
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    public void add(E e) {
        checkForComodification();
        if (prev == null) { // empty list
            SinglyLinkedListNode.this.value = e;
            SinglyLinkedListNode.this.next = null;
            cur = SinglyLinkedListNode.this;
        } else if (cur == null) {  // linkLast
            prev.next = new SinglyLinkedListNode&lt;&gt;(e, null);
        } else {
            final SinglyLinkedListNode&lt;E&gt; newNode = new SinglyLinkedListNode&lt;&gt;(e, cur.next);
            cur.next = newNode;
        }
        modCount++;
        expectedModCount++;
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
</code></pre>

<p>}
```</p>

<p>Then comes with the unit tests:</p>

<p>```java
package org.algorithmhub.customized_collection;</p>

<p>import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;
import static org.junit.Assert.assertEquals;</p>

<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;</p>

<p>public class SinglyLinkedListTest {</p>

<pre><code>@Test public void singlyLinkedListTest() throws IOException {
    final ObjectMapper objectMapper = new ObjectMapper();

    final SinglyLinkedListNode&lt;Integer&gt; emptyList = objectMapper.readValue("[]",
        new TypeReference&lt;SinglyLinkedListNode&lt;Integer&gt;&gt;() {});
    final SinglyLinkedListNode&lt;Integer&gt; emptyListExpected = new SinglyLinkedListNode&lt;&gt;();
    assertEquals(emptyListExpected, emptyList);

    // the time complexity is O(n)
    final SinglyLinkedListNode&lt;Integer&gt; intList = objectMapper.readValue("[1,2,3,4,5]",
        new TypeReference&lt;SinglyLinkedListNode&lt;Integer&gt;&gt;() {});
    final SinglyLinkedListNode&lt;Integer&gt; intListExpected = new SinglyLinkedListNode&lt;&gt;(1,
        new SinglyLinkedListNode&lt;&gt;(2,
            new SinglyLinkedListNode&lt;&gt;(3,
                new SinglyLinkedListNode&lt;&gt;(4,
                    new SinglyLinkedListNode&lt;&gt;(5, null)))));
    intListExpected.next = new SinglyLinkedListNode&lt;&gt;(2,
        new SinglyLinkedListNode&lt;&gt;(3,
            new SinglyLinkedListNode&lt;&gt;(4,
                new SinglyLinkedListNode&lt;&gt;(5, null))));
    assertEquals(intListExpected, intList);

    final ArrayList&lt;SinglyLinkedListNode&lt;Integer&gt;&gt; arrayOfList = objectMapper.readValue("[[1,2,3], [4,5,6]]",
        new TypeReference&lt;ArrayList&lt;SinglyLinkedListNode&lt;Integer&gt;&gt;&gt;() {});
    final ArrayList&lt;SinglyLinkedListNode&lt;Integer&gt;&gt; arrayOfListExpected = new ArrayList(Arrays.asList(
        new SinglyLinkedListNode&lt;&gt;(Arrays.asList(1, 2, 3)),
        new SinglyLinkedListNode&lt;&gt;(Arrays.asList(4, 5, 6))));
    assertEquals(arrayOfListExpected, arrayOfList);
}
</code></pre>

<p>}
```</p>

<h2>Related Posts</h2>

<p><a href="http://www.soulmachine.me/blog/2015/06/22/deserialize-a-json-string-to-a-binary-tree/">Deserialize a JSON String to a Binary Tree</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Code Style and Static Analysis]]></title>
    <link href="http://www.soulmachine.me/blog/2014/12/15/java-code-style-and-static-analysis/"/>
    <updated>2014-12-15T11:42:09-08:00</updated>
    <id>http://www.soulmachine.me/blog/2014/12/15/java-code-style-and-static-analysis</id>
    <content type="html"><![CDATA[<h2>1. Checkstyle</h2>

<p><a href="http://checkstyle.sourceforge.net/">CheckStyle</a> is a development tool to help programmers write Java code that adheres to a coding standard. It automates the process of checking Java code to spare humans of this boring (but important) task. This makes it ideal for projects that want to enforce a coding standard.</p>

<p>Which Java code style to choose? Google has published a few coding standards, include <a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>. Aditionally, there are xml configuration files for Eclipse and IntelliJ in the SVN repository, <a href="https://code.google.com/p/google-styleguide/source/browse/trunk">https://code.google.com/p/google-styleguide/source/browse/trunk</a>.</p>

<p>Checkstyle Eclipse plugin has already used Google Java style by default, checkt it by clicking &ldquo;Window->Preferences->Checkstyle->Global Check Configurations&rdquo;, or at <a href="https://github.com/checkstyle/checkstyle/blob/master/google_checks.xml">https://github.com/checkstyle/checkstyle/blob/master/google_checks.xml</a>.</p>

<h3>1.1 Checkstyle Eclipse Plugin</h3>

<p>To check your coding style automatically in Eclipse, just install the Checkstyle Eclpise plugin. Launch Eclipse, click Menu &ldquo;Help &ndash;> Install New Software&rdquo;, input
<a href="http://eclipse-cs.sf.net/update/">http://eclipse-cs.sf.net/update/</a>, then click &ldquo;Next&rdquo; to install the plugin.</p>

<h3>1.2 Checkstyle Maven Plugin</h3>

<p>Add the following lines to pom.xml to enable Checkstyle:</p>

<pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.13&lt;/version&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;com.puppycrawl.tools&lt;/groupId&gt;
                    &lt;artifactId&gt;checkstyle&lt;/artifactId&gt;
                    &lt;version&gt;6.1.1&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;checkstyle&lt;/id&gt;
                    &lt;phase&gt;validate&lt;/phase&gt;
                    &lt;configuration&gt;
                        &lt;configLocation&gt;google_checks.xml&lt;/configLocation&gt;
                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                        &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;
                        &lt;failsOnError&gt;true&lt;/failsOnError&gt;
                        &lt;includeTestSourceDirectory&gt;true&lt;/includeTestSourceDirectory&gt;
                    &lt;/configuration&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;checkstyle&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
&lt;reporting&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.13&lt;/version&gt;
            &lt;configuration&gt;
                &lt;configLocation&gt;https://raw.githubusercontent.com/checkstyle/checkstyle/master/google_checks.xml&lt;/configLocation&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-jxr-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/reporting&gt;
</code></pre>

<!-- more -->


<h2>1.3 Maven Eclipse Plugin</h2>

<p>To format source code automatically according to Google Java style, import the file <a href="https://google-styleguide.googlecode.com/svn/trunk/eclipse-java-google-style.xml">eclipse-java-google-style.xml</a> into Eclipse by clicking menu &ldquo;Window->Preferences->Java->Code Style->Formatter->Import&rdquo;.</p>

<p>You can add the code style automatically via Maven, add the following lines to pom.xml:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.9&lt;/version&gt;
    &lt;configuration&gt;
        &lt;downloadSources&gt;true&lt;/downloadSources&gt;
        &lt;downloadJavadocs&gt;true&lt;/downloadJavadocs&gt;
        &lt;workspace&gt;${basedir}&lt;/workspace&gt;
        &lt;workspaceCodeStylesURL&gt;https://google-styleguide.googlecode.com/svn/trunk/eclipse-java-google-style.xml&lt;/workspaceCodeStylesURL&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<h2>2 PMD</h2>

<p>Checking code style is not enough, there are many static anaylysis tools which can analyze your code and find potential bugs, for example PMD, findbugs, etc. The difference between them is <a href="http://www.sw-engineering-candies.com/blog-1/comparison-of-findbugs-pmd-and-checkstyle">http://www.sw-engineering-candies.com/blog-1/comparison-of-findbugs-pmd-and-checkstyle</a>.</p>

<p><a href="http://pmd.sourceforge.net/">PMD</a> is a source code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth.</p>

<h3>2.1 PMD Eclipse Plugin</h3>

<p>PMD Eclipse plugin update site:
<a href="http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/">http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/</a>.</p>

<h3>2.2 Maven PMD Plugin</h3>

<p>To enable automatically static analysis during compilation, add the following lines to pom.xml:</p>

<pre><code>&lt;build&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3&lt;/version&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;phase&gt;validate&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;check&lt;/goal&gt;
                    &lt;goal&gt;cpd-check&lt;/goal&gt;
                &lt;/goals&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
&lt;/build&gt;
&lt;reporting&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.3&lt;/version&gt;
            &lt;reportSets&gt;
                &lt;reportSet&gt;
                    &lt;reports&gt;
                        &lt;report&gt;pmd&lt;/report&gt;
                        &lt;report&gt;cpd&lt;/report&gt;
                    &lt;/reports&gt;
                &lt;/reportSet&gt;
            &lt;/reportSets&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/reporting&gt;
</code></pre>

<h2>3. FindBugs</h2>

<h3>3.1 FindBugs Eclipse Plugin</h3>

<p>Eclipse Update Site: <a href="http://findbugs.cs.umd.edu/eclipse">http://findbugs.cs.umd.edu/eclipse</a></p>

<h3>3.2 Maven FindBugs Plugin</h3>

<p>Official site: <a href="http://mojo.codehaus.org/findbugs-maven-plugin/">http://mojo.codehaus.org/findbugs-maven-plugin/</a></p>

<p>To configure your build to fail if any errors are found in the FindBugs report, add the following lines to pom.xml.</p>

<pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
            &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.0.1-SNAPSHOT&lt;/version&gt;
            &lt;configuration&gt;
                &lt;effort&gt;Max&lt;/effort&gt;
                &lt;threshold&gt;Low&lt;/threshold&gt;
                &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;check&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>Reference: <a href="http://mojo.codehaus.org/findbugs-maven-plugin/examples/violationChecking.html">http://mojo.codehaus.org/findbugs-maven-plugin/examples/violationChecking.html</a></p>

<h2>4. What&rsquo;s next?</h2>

<p>Nowadays there are many tools that are more powerful and automatic, for example, <a href="http://www.sonarqube.org/">SonarQube</a>, <a href="http://www.coverity.com/">Coverity</a>. SonarQube is an open source quality management platform, dedicated to continuously analyze and measure source code quality, and has been used by <a href="http://zeroturnaround.com/rebellabs/developers-guide-static-code-analysis-findbugs-checkstyle-pmd-coverity-sonarqube/">many companies</a>, I will try it in the next step.</p>
]]></content>
  </entry>
  
</feed>
